<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta content="width=device-width,initial-scale=1" name="viewport">
    <title>Jake (js837)</title>
    <meta content="Jake" name="author">
    <meta content="algorithms,programming" name="keywords">
    <link rel="stylesheet" type="text/css" href="/assets/style.css">

</head>
<body>


<div class="header">
    Sorting algorithms
</div>


<p>
Here is a reference guide of a few of the main efficient sorting
algorithms. CPython uses Timsort.
</p>


<h4>Quick sort</h4>
<p>
    best = O(n log n)
    average = O(n log n)
    worst = O(n^2)
    stable = no
</p>
<pre class="prettyprint lang-python">
def quick_sort(list):
    if not list:
        return []
    else:
        pivot = list[0]
        less = [x for x in list     if x <  pivot]
        more = [x for x in list[1:] if x >= pivot]
        return qsort(less) + [pivot] + qsort(more)
</pre>





<h4>Merge sort</h4>
<p>
    best = O(n log n)
    worst = O(n log n)
    average = O(n log n)
    stable = yes
</p>
<pre class="prettyprint lang-python">
def merge_sort(m):
    if len(m) <= 1:
        return m

    middle = len(m) // 2
    left = m[:middle]
    right = m[middle:]

    left = merge_sort(left)
    right = merge_sort(right)
    return list(merge(left, right))

def merge(left, right):
    result = []
    left_idx, right_idx = 0, 0
    while left_idx < len(left) and right_idx < len(right):
        # change the direction of this comparison to change the direction of the sort
        if left[left_idx] <= right[right_idx]:
            result.append(left[left_idx])
            left_idx += 1
        else:
            result.append(right[right_idx])
            right_idx += 1

    if left:
        result.extend(left[left_idx:])
    if right:
        result.extend(right[right_idx:])
    return result
</pre>




<h4>Heap sort</h4>
<p>
    best = O(n log n)
    average = O(n log n)
    worst = O(n log n)
    stable = no
</p>
<pre class="prettyprint lang-python">
def heap_sort(lst):
    for start in range((len(lst)-2)/2, -1, -1):
        siftdown(lst, start, len(lst)-1)

    for end in range(len(lst)-1, 0, -1):
        lst[end], lst[0] = lst[0], lst[end]
        siftdown(lst, 0, end - 1)
    return lst

def siftdown(lst, start, end):
    root = start
    while True:
        child = root * 2 + 1
        if child > end: break
        if child + 1 <= end and lst[child] < lst[child + 1]:
            child += 1
        if lst[root] < lst[child]:
            lst[root], lst[child] = lst[child], lst[root]
            root = child
        else:
            break
</pre>





<h4>Bogosort</h4>
<p>
    best = O(n)
    average = O((n+1)!)
    worst = Inf
    stable = no
</p>
<pre class="prettyprint lang-python">
import random

def bogo_sort(numbers):
    while not is_sorted(numbers):
        random.shuffle(numbers)

def is_sorted(numbers):
    for i in range(1, len(numbers)):
        if numbers[i-1] > numbers[i]:
            return False
    return True
</pre>





<script src="/assets/run_prettify.js"></script>

</body>
</html>